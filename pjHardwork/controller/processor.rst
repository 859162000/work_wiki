============
自定义处理器
============

next : 计数器
简介
====
本文的设计目标是一种异步的、基于逻辑定义的处理器。
异步是指在流水级上，不用时钟同步，而是通过判断本级计算是否完成来驱动数据流动。
逻辑定义是指处理器运算逻辑不是用二进制逻辑电路直接进行运算，而是通过定义计算
逻辑，在计算时查找逻辑定义完成运算。


整体架构
========
存储器=》运算器=》存储器

异步模块完成运算检验方式：
1. 模块初始化时，置action_once位为0
2. 每次触发时，触发管理器发送触发时钟和校验位
3. 校验位按101010的顺序翻转


结构
====

数据定义
--------
数据通过ASCII和UTF-8定义。

寻址
----
- 计数寻址。用计数器计算移位次数，计算地址。
- 标志寻址。每行定义唯一码，码匹配确定地址。
- 编码寻址。按顺序编码，用译码器确定地址。

指令寄存器使用标志寻址。
指令顺序执行，在跳转时，才需要确定目标地址。
所有的可以接收跳转的指令通过定义唯一标志能够确定唯一地址。

计数器
------
作用：每触发一次，计数加1，到10返回到0。
计数器的基本原理是移位和数的定义。将十个数从0到9排列，从0开始移位计数。
`计数器<counter.rst>`_ 存储指令或数据。

数据存储
--------
寄存器：沿触发，输入稳定时间短，阻止数据抖动传递。
Latch：高通，下降沿存储，半周期抖动传递。
`寄存器堆<regfile.rst>`_ 存储指令或数据。

下一指令
--------
计算下一指令地址

指令
====

=========  ========  =========================================
名称       编码      说明
=========  ========  =========================================
跳转                 跳转到指令寄存器某一行地址。
结束                 系统停止工作。
=========  ========  =========================================


自定义加法器处理器
==================
逻辑电路能够进行加法计算，这里为了展示自定义的功能，在处理器中没有设计加法器。
为处理器增加加法器，类似于编程实现加法。
那么，加法是如何定义的？

数的表达
--------
list: 列表计数。

- 个位数：[0, 1, 2, 3, ..., 9]
- 多位数：[[千][百][十][个]]

加法定义
--------
加法：add。查找后续第n个数。

算法
~~~~
两个个位数加法。

:: 

  add_list = ['0','1','2','3','4','5','6','7','8','9']
  for x in range(b):
      a = next(a)

逻辑
~~~~
主逻辑::

  加列表寄存器堆依次存储0~9十个字符串
  置加列表寄存器当前地址（加址）为被加数
  计数器列表寄存器堆依次存储0~9十个字符串
  置计数器列表寄存器当前地址（计址）为0
  循环1：
  如果计址值不等于加数，
    计址取下一个
    加址取下一个
    跳转循环1
  否则，结束

地址取下一个，使用循环移位寄存器实现::

  如果当前地址是最后一位，
    置溢出位为1

    

电路结构
--------
两个循环列表寄存器。

.. image:: ./_static/CircleListRegfile.jpg

端口列表:

==========  =================  ======  ======  ==================================================
名称        变量名             方向    位长    说明
==========  =================  ======  ======  ==================================================
状态控制    state_control      i       1       1:setting 0:work 
行复位      line_pointer_rst   i       1       1:Yes 置行指针到起始位置
行置位      line_pointer_set   i       1       1:Yes 置行指针到写入数据所代表的位置
写入数据    write_data         i       8       用于写入存储的数据
轮回        transmigration     o       1       1:Yes 指示移位寄存器是否移过最后一位。
行指针地址  line_pointer_addr  o       8       当前输出数据行地址, 只有一位是高。
当前数据    cur_data           o       8       当前行数据
==========  =================  ======  ======  ==================================================

写入存储数据时，先进行行复位，再依行写入数据。
行置位时，写入数据从左至右的第一个高位代表行指针位置。
地址不进行编码，因为所有的数据是用ASCII码表示，与二进制编码不同。

工作状态：（控制位：{state_control, line_pointer_set, line_pointer_rst}）

==============  ========================================================
state code      action
==============  ========================================================
10x             将写入数据的值写入当前行，完成后行指针后移一位
11x             将根据写入数据的值，置当前行位置
xx1             置当前行为起始行（第一行），轮回置0
0xx             正常工作
1xx             轮回置0
==============  ========================================================

工作流
------
1. 设置列表长度（TODO: 可配置列表长度）
2. 加载列表数据
3. 置当前地址

传送带
======

传送带（converyor）是一种数据同步机制，取代时钟同步。
同步机制是 next + get ：
当上级输出有效时，next = 1
当next = 1，下级获取数据，置get = 1
当get = 1，上级置next = 0
当next = 0，下级置get = 0
当get = 0 && next = 0，上级输出下一行数据并置next = 1

每个器件在全局有一个寄存器，保存next get的值。


数据传递的方式：主动推出，主动取入，被动推入，被动取出
对于流水级作业，每拍每级都能完成任务，不用缓存，按时钟工作。
对于传送带机制，每级逻辑长度不同，处理时间不同，需要考虑输出数据是否被下级获取，
或者输出数据是否要抛弃。
