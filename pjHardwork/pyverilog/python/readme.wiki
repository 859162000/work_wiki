
= 功能 =
* 提供硬件结构模型，
* 提供硬件仿真机制
* 可以用来描述硬件结构、功能，仿真硬件行为、功能
* 能够生成结构层次模型。
= 行为 =
* 用标准模型生成硬件模块module结构（层次与连接关系）
* 在功能函数中定义模块的功能。
* 在测试模块testbench中，设置起始条件、动态外部条件，进行仿真。
* 从测试模块中的顶层模块开始进行仿真
* 先计算模块，后计算线
* 深度优先
* 默认每个功能的延时都是最小计算精度，意味着模块越多，延时越长。
= 结构 =
* 硬件结构：Module.(Port), Net.(Port)
	* Net是Module的一种。
* 硬件功能：Module.(Function)
* 模块通过Port与外部互连
* Net连接Port，实现模块互连
* 不同的模块可以共用一个Port，此时，值传递过程没有延时。
* 信号单向传输。驱动Driver到负载Loader。单驱动，多负载。
* Net中，不实例化新的Port，而是指向模块的Port。
* 数据以二进制形式存储。当更新数据时，生成新的对象，
* 子模块中，可以直接用set_value()传递值。
= 延时与值传递 =
在功能实现时，默认都是一拍完成。在值传递时，也是默认一拍完成。
仿真时，先完成所有模块的逻辑功能仿真，然后传递模块的值。
这样的效果类似在每个模块的输出端增加了一个触发器。
实现它的机制是利用python的字符串不能被修改的特性。

模块有出口与入口。逻辑仿真完成后，出口立即指向结果字符串，而下级入口仍指向旧结果字符串。
在模块与模块传递值时，入口指向上级出口所指向的字符串，完成值传递。
= 对象 =
* 结构
    - 字典类型{名称：对象}
    - {模块：{名称:""，端口:[]，模块:[]，连线:[]}}
* Port
	- _value : 接口的当前状态0/1
	- _width : 接口位宽
	- _direc : input/output标记端口方向
    - get_value() : 返回接口值
    - set_value() : 设置接口值，用户定义。检查位宽。
    - _pass_value() : net向接口传递值的函数。
* Module
    - __call__() : _run,_func，
    - _define() : 定义 子模块，内部线，内部端口
    - _run() : 遍历子模块和线
    - _func() : 模块功能
    - _pass() : 子模块接口
* Net
	- _dirver : 驱动,port
	- _loader : 负载,list[port]
	- _checkMatch : 检查是否驱动与负载定义是否匹配
    - _checkDriver : 检查是否是port和output
    - _checkLoader : 检查是否是port list和input
	- _checkWidth : 检查位宽
	- __call__() : 传递值。
	- set_driver() : 设置驱动端口
	- add_loader() : 增加负载端口

* *公用属性* ：
    - #_insName	: 用来标识对象
    - #_master	: 层次描述，记录自己所处的层次。testbench是最顶层
    - checkName()	: 检查命名是否合法
    - addMaster()	: 增加master列表
    - changeDataFormat() : int 到 二进制
= 变量命名规则 =
* self.pi/po/pb     : 端口，入，出，双
* self.n            : 线
* self.m            : 子模块
= 仿真 =
* 在功能描述时，所有的数据从接口port传递的数据都是二进制字符串类型。
在内部使用时，需要注意格式。
* 在向外传递数据时，只能使用int和二进制格式。
* 端口定义时，实例化端口在最低层子模块中？
* 能够实时追踪Port的值。
== 模块 ==
# 在_func()中定义函数的功能。
# 在_define()中，定义子模块，内部线，内部端口
# 在_pass()中，实现子模块端口连接。
= 函数 =
== 公共函数 ==


== 数据表达方式 ==
内部数据全部采用2进制字符串表示。
在进行连接位宽检查时（通常是初始化过程），将int型数据变成bin型。
在进行拼接时，list(str)实现
拼接的取值表达方式与python list类的方式保持一致。
== 类设置 ==
 basic
    |
    v
 ##delayBlock, noDelayBlock
    |              |
    |              |
    v              v
  module          pin   
    |              |
    v              v
  net         CpinOu, CpinIn 

example:
module(module_name)
Net(name,connection)
a = MA(ma)
b = MA(mb)
c = Net(name,a.out,b.in1)
d = Net(name,a.out,b.in1,bin2)

 = TODO: =
   * [ ] pin/net 拆分与组合赋值。
   * [ ] 判断，如果输入没有变化，功能不执行。
	 如果功能不是。


=== 基本 ===
=== 连接 ===
=== 模块 ===

地址从1开始。
= 数字与字符编码 =
数据直接用二进制翻译

| Num | 编码     | 16bit | 操作符 | 说明    |   |   |
|-----|----------|-------|--------|---------|---|---|
| 1   | 11000000 | c0    | 加     | +       |   |   |
| 2   | 11000001 | c1    | 减     | -       |   |   |
| 3   | 11000010 | c2    | 乘     | *       |   |   |
| 4   | 11000011 | c3    | 除     | /       |   |   |
| 5   | 11000100 | c4    | 正     | +       |   |   |
| 6   | 11000101 | c5    | 负     | -       |   |   |
| 7   | 11000110 | c6    | 大     | >       |   |   |
| 8   | 11000111 | c7    | 小     | <       |   |   |
| 9   | 11001000 | c8    | 等     | ==      |   |   |
| 10  | 11001001 | c9    | 非     | !=      |   |   |
| 11  | 11001010 | c10   | 余     | 余数    |   |   |
| 12  | 11001011 | c11   | 点     | 小数点. |   |   |
| 13  | 11001100 | c12   | 分     | 分式    |   |   |
| 14  | 11001101 | c13   |        |         |   |   |
| 15  | 11001110 | c14   |        |         |   |   |
| 16  | 11001111 | c15   |        |         |   |   |


相关性：寄存器有一个状态，1代表有效，0代表无用。有效，则其它指令不能对其进行写操作，无用则可写。用于编译有效性检察？或运行时检察。
寄存器有行号，对其进行读操作时，判断指令中的行号与寄存器的行号是否相同。其作用是，读相关指令数据有效性。
寄存器有进程号，不同的进程间，不能相互覆盖。
= 模块 =
寄存器
regfile.py
= 查表加法器 =
tableAdder.v
= 基本思想 =
计算机是为了强化计算的。所以目前计算机的数据表达是以2进制为基本的，处理方式是计算逻辑。

所有的信息都是字符串。数字也是字符串。人在传递信息时，使用文字，而非人脑的存储。计算与表达之间，有一层转换过程。计算机也是如此。
在计算机内部，只有01的操作。所有的表达，都是通过输入与输出系统完成。则计算机基本结构：输入，运算，输出。

计算机基本原理是可计算性，基本原型是图灵机。

# 高可靠性处理器：三组单元复合，得到一个结果；反馈结果。
# 地址0内存储的内容不可靠。
# 每一拍，从取指到结果存储
# 反馈结构：通过反馈结果，指示下一指令发射

= 指令寄存器堆结构 =
增加一列移位寄存器。寄存器只有一个高电平，用来选择指令行。每拍自动向后移位。当遇到跳转指令时，计算绝对地址，进行地址译码。

= 指令 =
加 减 乘 除
正跳
反跳
裸跳
加载、停止、复位

| 操作  （操作符） | 结果地址 | 源       | 源     | 备注                            |
|------------------|----------|----------|--------|---------------------------------|
| 运算  算术运算   | 寄存器   | 寄存器   | 寄存器 |                                 |
| 跳转  条件运算   | 命令行号 | 寄存器   | 寄存器 |                                 |
| 移动             | 寄存器   | 数1      | 数2    | 将数1、数2 存在连续的寄存器中。 |
| 加载             | 命令行号 | 内存地址 | 长度   | 定长、绝址                      |
| 存储             | 内存地址 | 寄、数   | 长度   | 定长、绝址                      |
| 读取             | 内存地址 | 硬盘地址 | 长度   |                                 |
| 保存             | 硬盘地址 | 内存地址 | 长度   |                                 |
